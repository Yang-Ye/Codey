<!-- HTML generated by Yang Ye --><div style="background: #ffffff; overflow:auto;width:auto;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span></span><span style="color: #888888">// Time:  O(h + k)</span>
<span style="color: #888888">// Space: O(h)</span>

<span style="color: #888888">/**</span>
<span style="color: #888888"> * Definition for a binary tree node.</span>
<span style="color: #888888"> * struct TreeNode {</span>
<span style="color: #888888"> *     int val;</span>
<span style="color: #888888"> *     TreeNode *left;</span>
<span style="color: #888888"> *     TreeNode *right;</span>
<span style="color: #888888"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}</span>
<span style="color: #888888"> * };</span>
<span style="color: #888888"> */</span>
<span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">Solution</span> {
<span style="color: #008800; font-weight: bold">public</span><span style="color: #333333">:</span>
    vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> closestKValues(TreeNode<span style="color: #333333">*</span> root, <span style="color: #333399; font-weight: bold">double</span> target, <span style="color: #333399; font-weight: bold">int</span> k) {
        <span style="color: #888888">// The forward or backward iterator.</span>
        <span style="color: #008800; font-weight: bold">const</span> <span style="color: #008800; font-weight: bold">auto</span> backward <span style="color: #333333">=</span> [](<span style="color: #008800; font-weight: bold">const</span> vector<span style="color: #333333">&lt;</span>TreeNode<span style="color: #333333">*&gt;&amp;</span> s) { <span style="color: #008800; font-weight: bold">return</span> s.back()<span style="color: #333333">-&gt;</span>left; };
        <span style="color: #008800; font-weight: bold">const</span> <span style="color: #008800; font-weight: bold">auto</span> forward <span style="color: #333333">=</span> [](<span style="color: #008800; font-weight: bold">const</span> vector<span style="color: #333333">&lt;</span>TreeNode<span style="color: #333333">*&gt;&amp;</span> s) { <span style="color: #008800; font-weight: bold">return</span> s.back()<span style="color: #333333">-&gt;</span>right; };
        <span style="color: #008800; font-weight: bold">const</span> <span style="color: #008800; font-weight: bold">auto</span> closest <span style="color: #333333">=</span> [<span style="color: #333333">&amp;</span>target](<span style="color: #008800; font-weight: bold">const</span> TreeNode<span style="color: #333333">*</span> a, <span style="color: #008800; font-weight: bold">const</span> TreeNode<span style="color: #333333">*</span> b) { 
                                <span style="color: #008800; font-weight: bold">return</span> abs(a<span style="color: #333333">-&gt;</span>val <span style="color: #333333">-</span> target) <span style="color: #333333">&lt;</span> abs(b<span style="color: #333333">-&gt;</span>val <span style="color: #333333">-</span> target); 
                            };

        <span style="color: #888888">// Build the stack to the closest node.</span>
        vector<span style="color: #333333">&lt;</span>TreeNode<span style="color: #333333">*&gt;</span> s;
        <span style="color: #008800; font-weight: bold">while</span> (root) {
            s.emplace_back(root);
            root <span style="color: #333333">=</span> target <span style="color: #333333">&lt;</span> root<span style="color: #333333">-&gt;</span>val <span style="color: #333333">?</span> root<span style="color: #333333">-&gt;</span><span style="color: #997700; font-weight: bold">left</span> : root<span style="color: #333333">-&gt;</span>right;
        }

        <span style="color: #888888">// Get the stack to the next smaller node.</span>
        vector<span style="color: #333333">&lt;</span>TreeNode<span style="color: #333333">*&gt;</span> forward_stack(s.cbegin(), next(min_element(s.cbegin(), s.cend(), closest)));
        vector<span style="color: #333333">&lt;</span>TreeNode<span style="color: #333333">*&gt;</span> backward_stack(forward_stack);
        nextNode(backward_stack, backward, forward);
    
        <span style="color: #888888">// Get the closest k values by advancing the iterators of the stacks.</span>
        vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">int</span><span style="color: #333333">&gt;</span> result;
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> k; <span style="color: #333333">++</span>i) {
            <span style="color: #008800; font-weight: bold">if</span> (<span style="color: #333333">!</span>forward_stack.empty() <span style="color: #333333">&amp;&amp;</span> 
                (backward_stack.empty() <span style="color: #333333">||</span> closest(forward_stack.back(), backward_stack.back()))) {
                result.emplace_back(forward_stack.back()<span style="color: #333333">-&gt;</span>val);
                nextNode(forward_stack, forward, backward);
            } <span style="color: #008800; font-weight: bold">else</span> <span style="color: #008800; font-weight: bold">if</span> (<span style="color: #333333">!</span>backward_stack.empty() <span style="color: #333333">&amp;&amp;</span>
                       (forward_stack.empty() <span style="color: #333333">||</span> <span style="color: #333333">!</span>closest(forward_stack.back(), backward_stack.back()))) {
                result.emplace_back(backward_stack.back()<span style="color: #333333">-&gt;</span>val);
                nextNode(backward_stack, backward, forward);
            }
        }
        <span style="color: #008800; font-weight: bold">return</span> result;
    }
    
    <span style="color: #888888">// Helper to make a stack to the next node.</span>
    <span style="color: #008800; font-weight: bold">template</span><span style="color: #333333">&lt;</span><span style="color: #008800; font-weight: bold">typename</span> T, <span style="color: #008800; font-weight: bold">typename</span> U<span style="color: #333333">&gt;</span>
    <span style="color: #333399; font-weight: bold">void</span> nextNode(vector<span style="color: #333333">&lt;</span>TreeNode<span style="color: #333333">*&gt;&amp;</span> s, <span style="color: #008800; font-weight: bold">const</span> T<span style="color: #333333">&amp;</span> child1, <span style="color: #008800; font-weight: bold">const</span> U<span style="color: #333333">&amp;</span> child2) {
        <span style="color: #008800; font-weight: bold">if</span> (<span style="color: #333333">!</span>s.empty()) {
            <span style="color: #008800; font-weight: bold">if</span> (child2(s)) {
                s.emplace_back(child2(s));
                <span style="color: #008800; font-weight: bold">while</span> (child1(s)) {
                    s.emplace_back(child1(s));
                }
            } <span style="color: #008800; font-weight: bold">else</span> {
                <span style="color: #008800; font-weight: bold">auto</span> child <span style="color: #333333">=</span> s.back();
                s.pop_back();
                <span style="color: #008800; font-weight: bold">while</span> (<span style="color: #333333">!</span>s.empty() <span style="color: #333333">&amp;&amp;</span> child <span style="color: #333333">==</span> child2(s)) {
                    child <span style="color: #333333">=</span> s.back();
                    s.pop_back();
                }
            }
        }
    }
};
</pre></div>
