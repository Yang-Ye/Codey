<!-- HTML generated by Yang Ye --><div style="background: #ffffff; overflow:auto;width:auto;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span></span><span style="color: #888888"># Time:  O(t! / (n1! * n2! * ... nk!)), t is the total number of tickets, </span>
<span style="color: #888888">#                                       ni is the number of the ticket which from is city i,</span>
<span style="color: #888888">#                                       k is the total number of cities.</span>
<span style="color: #888888"># Space: O(t)</span>

<span style="color: #888888"># Given a list of airline tickets represented by pairs of departure</span>
<span style="color: #888888"># and arrival airports [from, to], reconstruct the itinerary in order.</span>
<span style="color: #888888"># All of the tickets belong to a man who departs from JFK.</span>
<span style="color: #888888"># Thus, the itinerary must begin with JFK.</span>
<span style="color: #888888">#</span>
<span style="color: #888888"># Note:</span>
<span style="color: #888888"># If there are multiple valid itineraries, you should return the itinerary</span>
<span style="color: #888888"># that has the smallest lexical order when read as a single string. </span>
<span style="color: #888888"># For example, the itinerary [&quot;JFK&quot;, &quot;LGA&quot;] has a smaller lexical</span>
<span style="color: #888888"># order than [&quot;JFK&quot;, &quot;LGB&quot;].</span>
<span style="color: #888888"># All airports are represented by three capital letters (IATA code).</span>
<span style="color: #888888"># You may assume all tickets may form at least one valid itinerary.</span>
<span style="color: #888888"># Example 1:</span>
<span style="color: #888888"># tickets = [[&quot;MUC&quot;, &quot;LHR&quot;], [&quot;JFK&quot;, &quot;MUC&quot;], [&quot;SFO&quot;, &quot;SJC&quot;], [&quot;LHR&quot;, &quot;SFO&quot;]]</span>
<span style="color: #888888"># Return [&quot;JFK&quot;, &quot;MUC&quot;, &quot;LHR&quot;, &quot;SFO&quot;, &quot;SJC&quot;].</span>
<span style="color: #888888"># Example 2:</span>
<span style="color: #888888"># tickets = [[&quot;JFK&quot;,&quot;SFO&quot;],[&quot;JFK&quot;,&quot;ATL&quot;],[&quot;SFO&quot;,&quot;ATL&quot;],[&quot;ATL&quot;,&quot;JFK&quot;],[&quot;ATL&quot;,&quot;SFO&quot;]]</span>
<span style="color: #888888"># Return [&quot;JFK&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;SFO&quot;].</span>
<span style="color: #888888"># Another possible reconstruction is [&quot;JFK&quot;,&quot;SFO&quot;,&quot;ATL&quot;,&quot;JFK&quot;,&quot;ATL&quot;,&quot;SFO&quot;].</span>
<span style="color: #888888"># But it is larger in lexical order.</span>

<span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">Solution</span>(<span style="color: #007020">object</span>):
    <span style="color: #008800; font-weight: bold">def</span> <span style="color: #0066BB; font-weight: bold">findItinerary</span>(<span style="color: #007020">self</span>, tickets):
        <span style="color: #DD4422">&quot;&quot;&quot;</span>
<span style="color: #DD4422">        :type tickets: List[List[str]]</span>
<span style="color: #DD4422">        :rtype: List[str]</span>
<span style="color: #DD4422">        &quot;&quot;&quot;</span>
        <span style="color: #008800; font-weight: bold">def</span> <span style="color: #0066BB; font-weight: bold">route_helper</span>(origin, ticket_cnt, graph, ans):
            <span style="color: #008800; font-weight: bold">if</span> ticket_cnt <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">0</span>:
                <span style="color: #008800; font-weight: bold">return</span> <span style="color: #007020">True</span>

            <span style="color: #008800; font-weight: bold">for</span> i, (dest, valid)  <span style="color: #000000; font-weight: bold">in</span> <span style="color: #007020">enumerate</span>(graph[origin]):
                <span style="color: #008800; font-weight: bold">if</span> valid:
                    graph[origin][i][<span style="color: #0000DD; font-weight: bold">1</span>] <span style="color: #333333">=</span> <span style="color: #007020">False</span>
                    ans<span style="color: #333333">.</span>append(dest)
                    <span style="color: #008800; font-weight: bold">if</span> route_helper(dest, ticket_cnt <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>, graph, ans):
                        <span style="color: #008800; font-weight: bold">return</span> ans
                    ans<span style="color: #333333">.</span>pop()
                    graph[origin][i][<span style="color: #0000DD; font-weight: bold">1</span>] <span style="color: #333333">=</span> <span style="color: #007020">True</span>
            <span style="color: #008800; font-weight: bold">return</span> <span style="color: #007020">False</span>

        graph <span style="color: #333333">=</span> collections<span style="color: #333333">.</span>defaultdict(<span style="color: #007020">list</span>)
        <span style="color: #008800; font-weight: bold">for</span> ticket <span style="color: #000000; font-weight: bold">in</span> tickets:
            graph[ticket[<span style="color: #0000DD; font-weight: bold">0</span>]]<span style="color: #333333">.</span>append([ticket[<span style="color: #0000DD; font-weight: bold">1</span>], <span style="color: #007020">True</span>])
        <span style="color: #008800; font-weight: bold">for</span> k <span style="color: #000000; font-weight: bold">in</span> graph<span style="color: #333333">.</span>keys():
            graph[k]<span style="color: #333333">.</span>sort()

        origin <span style="color: #333333">=</span> <span style="background-color: #fff0f0">&quot;JFK&quot;</span>
        ans <span style="color: #333333">=</span> [origin]
        route_helper(origin, <span style="color: #007020">len</span>(tickets), graph, ans)
        <span style="color: #008800; font-weight: bold">return</span> ans
</pre></div>
