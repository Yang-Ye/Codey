<!-- HTML generated by Yang Ye --><div style="background: #ffffff; overflow:auto;width:auto;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span></span><span style="color: #888888"># Time:  O(n)</span>
<span style="color: #888888"># Space: O(n)</span>

<span style="color: #888888"># For a undirected graph with tree characteristics, we can</span>
<span style="color: #888888"># choose any node as the root. The result graph is then a</span>
<span style="color: #888888"># rooted tree. Among all possible rooted trees, those with</span>
<span style="color: #888888"># minimum height are called minimum height trees (MHTs).</span>
<span style="color: #888888"># Given such a graph, write a function to find all the </span>
<span style="color: #888888"># MHTs and return a list of their root labels.</span>
<span style="color: #888888">#</span>
<span style="color: #888888"># Format</span>
<span style="color: #888888"># The graph contains n nodes which are labeled from 0 to n - 1.</span>
<span style="color: #888888"># You will be given the number n and a list of undirected</span>
<span style="color: #888888"># edges (each edge is a pair of labels).</span>
<span style="color: #888888">#</span>
<span style="color: #888888"># You can assume that no duplicate edges will appear in edges.</span>
<span style="color: #888888"># Since all edges are undirected, [0, 1] is the same as [1, 0]</span>
<span style="color: #888888"># and thus will not appear together in edges.</span>
<span style="color: #888888">#</span>
<span style="color: #888888"># Example 1:</span>
<span style="color: #888888">#</span>
<span style="color: #888888"># Given n = 4, edges = [[1, 0], [1, 2], [1, 3]]</span>
<span style="color: #888888">#</span>
<span style="color: #888888">#         0</span>
<span style="color: #888888">#         |</span>
<span style="color: #888888">#         1</span>
<span style="color: #888888">#        / \</span>
<span style="color: #888888">#       2   3</span>
<span style="color: #888888"># return [1]</span>
<span style="color: #888888">#</span>
<span style="color: #888888"># Example 2:</span>
<span style="color: #888888">#</span>
<span style="color: #888888"># Given n = 6, edges = [[0, 3], [1, 3], [2, 3], [4, 3], [5, 4]]</span>
<span style="color: #888888">#</span>
<span style="color: #888888">#      0  1  2</span>
<span style="color: #888888">#       \ | /</span>
<span style="color: #888888">#         3</span>
<span style="color: #888888">#         |</span>
<span style="color: #888888">#         4</span>
<span style="color: #888888">#         |</span>
<span style="color: #888888">#         5</span>
<span style="color: #888888"># return [3, 4]</span>
<span style="color: #888888">#</span>
<span style="color: #888888"># Hint:</span>
<span style="color: #888888">#</span>
<span style="color: #888888"># How many MHTs can a graph have at most?</span>
<span style="color: #888888"># Note:</span>
<span style="color: #888888">#</span>
<span style="color: #888888"># (1) According to the definition of tree on Wikipedia: </span>
<span style="color: #888888">#     &quot;a tree is an undirected graph in which any two vertices </span>
<span style="color: #888888">#     are connected by exactly one path. In other words, </span>
<span style="color: #888888">#     any connected graph without simple cycles is a tree.&quot;</span>
<span style="color: #888888">#</span>
<span style="color: #888888"># (2) The height of a rooted tree is the number of edges on the </span>
<span style="color: #888888">#     longest downward path between the root and a leaf.</span>

<span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">Solution</span>(<span style="color: #007020">object</span>):
    <span style="color: #008800; font-weight: bold">def</span> <span style="color: #0066BB; font-weight: bold">findMinHeightTrees</span>(<span style="color: #007020">self</span>, n, edges):
        <span style="color: #DD4422">&quot;&quot;&quot;</span>
<span style="color: #DD4422">        :type n: int</span>
<span style="color: #DD4422">        :type edges: List[List[int]]</span>
<span style="color: #DD4422">        :rtype: List[int]</span>
<span style="color: #DD4422">        &quot;&quot;&quot;</span>
        <span style="color: #008800; font-weight: bold">if</span> n <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">1</span>:
            <span style="color: #008800; font-weight: bold">return</span> [<span style="color: #0000DD; font-weight: bold">0</span>]

        neighbors <span style="color: #333333">=</span> collections<span style="color: #333333">.</span>defaultdict(<span style="color: #007020">set</span>)
        <span style="color: #008800; font-weight: bold">for</span> u, v <span style="color: #000000; font-weight: bold">in</span> edges:
            neighbors[u]<span style="color: #333333">.</span>add(v)
            neighbors[v]<span style="color: #333333">.</span>add(u)

        pre_level, unvisited <span style="color: #333333">=</span> [], <span style="color: #007020">set</span>()
        <span style="color: #008800; font-weight: bold">for</span> i <span style="color: #000000; font-weight: bold">in</span> <span style="color: #007020">xrange</span>(n):
            <span style="color: #008800; font-weight: bold">if</span> <span style="color: #007020">len</span>(neighbors[i]) <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">1</span>:  <span style="color: #888888"># A leaf.</span>
                pre_level<span style="color: #333333">.</span>append(i)
            unvisited<span style="color: #333333">.</span>add(i)

        <span style="color: #888888"># A graph can have 2 MHTs at most.</span>
        <span style="color: #888888"># BFS from the leaves until the number </span>
        <span style="color: #888888"># of the unvisited nodes is less than 3.</span>
        <span style="color: #008800; font-weight: bold">while</span> <span style="color: #007020">len</span>(unvisited) <span style="color: #333333">&gt;</span> <span style="color: #0000DD; font-weight: bold">2</span>:
            cur_level <span style="color: #333333">=</span> []
            <span style="color: #008800; font-weight: bold">for</span> u <span style="color: #000000; font-weight: bold">in</span> pre_level:
                unvisited<span style="color: #333333">.</span>remove(u)
                <span style="color: #008800; font-weight: bold">for</span> v <span style="color: #000000; font-weight: bold">in</span> neighbors[u]:
                    <span style="color: #008800; font-weight: bold">if</span> v <span style="color: #000000; font-weight: bold">in</span> unvisited: 
                        neighbors[v]<span style="color: #333333">.</span>remove(u)
                        <span style="color: #008800; font-weight: bold">if</span> <span style="color: #007020">len</span>(neighbors[v]) <span style="color: #333333">==</span> <span style="color: #0000DD; font-weight: bold">1</span>:
                            cur_level<span style="color: #333333">.</span>append(v)
            pre_level <span style="color: #333333">=</span> cur_level
    
        <span style="color: #008800; font-weight: bold">return</span> <span style="color: #007020">list</span>(unvisited)
</pre></div>
