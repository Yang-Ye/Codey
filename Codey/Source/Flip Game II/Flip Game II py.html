<!-- HTML generated by Yang Ye --><div style="background: #ffffff; overflow:auto;width:auto;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span></span><span style="color: #888888"># Time:  O(n + c^2)</span>
<span style="color: #888888"># Space: O(c)</span>

<span style="color: #888888"># The best theory solution (DP, O(n + c^2)) could be seen here:</span>
<span style="color: #888888"># https://leetcode.com/discuss/64344/theory-matters-from-backtracking-128ms-to-dp-0m</span>
<span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">Solution</span>(<span style="color: #007020">object</span>):
    <span style="color: #008800; font-weight: bold">def</span> <span style="color: #0066BB; font-weight: bold">canWin</span>(<span style="color: #007020">self</span>, s):
        g, g_final <span style="color: #333333">=</span> [<span style="color: #0000DD; font-weight: bold">0</span>], <span style="color: #0000DD; font-weight: bold">0</span>
        <span style="color: #008800; font-weight: bold">for</span> p <span style="color: #000000; font-weight: bold">in</span> itertools<span style="color: #333333">.</span>imap(<span style="color: #007020">len</span>, re<span style="color: #333333">.</span>split(<span style="background-color: #fff0f0">&#39;-+&#39;</span>, s)):
            <span style="color: #008800; font-weight: bold">while</span> <span style="color: #007020">len</span>(g) <span style="color: #333333">&lt;=</span> p:
                <span style="color: #888888"># Theorem 2: g[game] = g[subgame1]^g[subgame2]^g[subgame3]...;</span>
                <span style="color: #888888"># and find first missing number.</span>
                g <span style="color: #333333">+=</span> <span style="color: #007020">min</span>(<span style="color: #007020">set</span>(<span style="color: #007020">xrange</span>(p)) <span style="color: #333333">-</span> {x<span style="color: #333333">^</span>y <span style="color: #008800; font-weight: bold">for</span> x, y <span style="color: #000000; font-weight: bold">in</span> itertools<span style="color: #333333">.</span>izip(g[:<span style="color: #007020">len</span>(g)<span style="color: #333333">/</span><span style="color: #0000DD; font-weight: bold">2</span>], g[<span style="color: #333333">-</span><span style="color: #0000DD; font-weight: bold">2</span>:<span style="color: #333333">-</span><span style="color: #007020">len</span>(g)<span style="color: #333333">/</span><span style="color: #0000DD; font-weight: bold">2</span><span style="color: #333333">-</span><span style="color: #0000DD; font-weight: bold">2</span>:<span style="color: #333333">-</span><span style="color: #0000DD; font-weight: bold">1</span>])}),
            g_final <span style="color: #333333">^=</span> g[p]
        <span style="color: #008800; font-weight: bold">return</span> g_final <span style="color: #333333">&gt;</span> <span style="color: #0000DD; font-weight: bold">0</span>  <span style="color: #888888"># Theorem 1: First player must win iff g(current_state) != 0</span>


<span style="color: #888888"># Time:  O(n + c^3 * 2^c * logc), n is length of string, c is count of &quot;++&quot;</span>
<span style="color: #888888"># Space: O(c * 2^c)</span>
<span style="color: #888888"># hash solution.</span>
<span style="color: #888888"># We have total O(2^c) game strings,</span>
<span style="color: #888888"># and each hash key in hash table would cost O(c),</span>
<span style="color: #888888"># each one has O(c) choices to the next one,</span>
<span style="color: #888888"># and each one would cost O(clogc) to sort,</span>
<span style="color: #888888"># so we get O((c * 2^c) * (c * clogc)) = O(c^3 * 2^c * logc) time.</span>
<span style="color: #888888"># To cache the results of all combinations, thus O(c * 2^c) space.</span>
<span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">Solution2</span>(<span style="color: #007020">object</span>):
    <span style="color: #008800; font-weight: bold">def</span> <span style="color: #0066BB; font-weight: bold">canWin</span>(<span style="color: #007020">self</span>, s):
        <span style="color: #DD4422">&quot;&quot;&quot;</span>
<span style="color: #DD4422">        :type s: str</span>
<span style="color: #DD4422">        :rtype: bool</span>
<span style="color: #DD4422">        &quot;&quot;&quot;</span>
        lookup <span style="color: #333333">=</span> {}

        <span style="color: #008800; font-weight: bold">def</span> <span style="color: #0066BB; font-weight: bold">canWinHelper</span>(consecutives):                                         <span style="color: #888888"># O(2^c) time</span>
            consecutives <span style="color: #333333">=</span> <span style="color: #007020">tuple</span>(<span style="color: #007020">sorted</span>(c <span style="color: #008800; font-weight: bold">for</span> c <span style="color: #000000; font-weight: bold">in</span> consecutives <span style="color: #008800; font-weight: bold">if</span> c <span style="color: #333333">&gt;=</span> <span style="color: #0000DD; font-weight: bold">2</span>))     <span style="color: #888888"># O(clogc) time</span>
            <span style="color: #008800; font-weight: bold">if</span> consecutives <span style="color: #000000; font-weight: bold">not</span> <span style="color: #000000; font-weight: bold">in</span> lookup:
                lookup[consecutives] <span style="color: #333333">=</span> <span style="color: #007020">any</span>(<span style="color: #000000; font-weight: bold">not</span> canWinHelper(consecutives[:i] <span style="color: #333333">+</span> (j, c<span style="color: #333333">-</span><span style="color: #0000DD; font-weight: bold">2</span><span style="color: #333333">-</span>j) <span style="color: #333333">+</span> consecutives[i<span style="color: #333333">+</span><span style="color: #0000DD; font-weight: bold">1</span>:])  <span style="color: #888888"># O(c) time</span>
                                           <span style="color: #008800; font-weight: bold">for</span> i, c <span style="color: #000000; font-weight: bold">in</span> <span style="color: #007020">enumerate</span>(consecutives)  <span style="color: #888888"># O(c) time</span>
                                           <span style="color: #008800; font-weight: bold">for</span> j <span style="color: #000000; font-weight: bold">in</span> <span style="color: #007020">xrange</span>(c <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>))              <span style="color: #888888"># O(c) time</span>
            <span style="color: #008800; font-weight: bold">return</span> lookup[consecutives]                                         <span style="color: #888888"># O(c) time</span>

        <span style="color: #888888"># re.findall: O(n) time, canWinHelper: O(c) in depth</span>
        <span style="color: #008800; font-weight: bold">return</span> canWinHelper(<span style="color: #007020">map</span>(<span style="color: #007020">len</span>, re<span style="color: #333333">.</span>findall(<span style="background-color: #fff0f0">r&#39;\+\++&#39;</span>, s)))


<span style="color: #888888"># Time:  O(c * n * c!), n is length of string, c is count of &quot;++&quot;</span>
<span style="color: #888888"># Space: O(c * n), recursion would be called at most c in depth.</span>
<span style="color: #888888">#                  Besides, it costs n space for modifying string at each depth.</span>
<span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">Solution3</span>(<span style="color: #007020">object</span>):
    <span style="color: #008800; font-weight: bold">def</span> <span style="color: #0066BB; font-weight: bold">canWin</span>(<span style="color: #007020">self</span>, s):
        <span style="color: #DD4422">&quot;&quot;&quot;</span>
<span style="color: #DD4422">        :type s: str</span>
<span style="color: #DD4422">        :rtype: bool</span>
<span style="color: #DD4422">        &quot;&quot;&quot;</span>
        i, n <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>, <span style="color: #007020">len</span>(s) <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>
        is_win <span style="color: #333333">=</span> <span style="color: #007020">False</span>
        <span style="color: #008800; font-weight: bold">while</span> <span style="color: #000000; font-weight: bold">not</span> is_win <span style="color: #000000; font-weight: bold">and</span> i <span style="color: #333333">&lt;</span> n:                                     <span style="color: #888888"># O(n) time</span>
            <span style="color: #008800; font-weight: bold">if</span> s[i] <span style="color: #333333">==</span> <span style="background-color: #fff0f0">&#39;+&#39;</span>:
                <span style="color: #008800; font-weight: bold">while</span> <span style="color: #000000; font-weight: bold">not</span> is_win <span style="color: #000000; font-weight: bold">and</span> i <span style="color: #333333">&lt;</span> n <span style="color: #000000; font-weight: bold">and</span> s[i<span style="color: #333333">+</span><span style="color: #0000DD; font-weight: bold">1</span>] <span style="color: #333333">==</span> <span style="background-color: #fff0f0">&#39;+&#39;</span>:           <span style="color: #888888"># O(c) time</span>
                     <span style="color: #888888"># t(n, c) = c * (t(n, c-1) + n) + n = ...</span>
                     <span style="color: #888888"># = c! * t(n, 0) + n * c! * (c + 1) * (1/0! + 1/1! + ... 1/c!)</span>
                     <span style="color: #888888"># = n * c! + n * c! * (c + 1) * O(e) = O(c * n * c!)</span>
                    is_win <span style="color: #333333">=</span> <span style="color: #000000; font-weight: bold">not</span> <span style="color: #007020">self</span><span style="color: #333333">.</span>canWin(s[:i] <span style="color: #333333">+</span> <span style="background-color: #fff0f0">&#39;--&#39;</span> <span style="color: #333333">+</span> s[i<span style="color: #333333">+</span><span style="color: #0000DD; font-weight: bold">2</span>:])    <span style="color: #888888"># O(n) space</span>
                    i <span style="color: #333333">+=</span> <span style="color: #0000DD; font-weight: bold">1</span>
            i <span style="color: #333333">+=</span> <span style="color: #0000DD; font-weight: bold">1</span>
        <span style="color: #008800; font-weight: bold">return</span> is_win
</pre></div>
