<!-- HTML generated by Yang Ye --><div style="background: #ffffff; overflow:auto;width:auto;border-width:.1em .1em .1em .8em;padding:.2em .6em;"><pre style="margin: 0; line-height: 125%"><span></span><span style="color: #888888">// Time:  O(n)</span>
<span style="color: #888888">// Space: O(|V|+|E|) = O(26 + 26^2) = O(1)</span>

<span style="color: #888888">// BFS solution.</span>
<span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">Solution</span> {
<span style="color: #008800; font-weight: bold">public</span><span style="color: #333333">:</span>
    string alienOrder(vector<span style="color: #333333">&lt;</span>string<span style="color: #333333">&gt;&amp;</span> words) {
        unordered_set<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">char</span><span style="color: #333333">&gt;</span> nodes;
        unordered_map<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">char</span>, unordered_set<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">char</span><span style="color: #333333">&gt;&gt;</span> in_degree, out_degree;
        queue<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">char</span><span style="color: #333333">&gt;</span> zero_in_degree_queue;
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #008800; font-weight: bold">const</span> <span style="color: #008800; font-weight: bold">auto</span><span style="color: #333333">&amp;</span> <span style="color: #997700; font-weight: bold">word</span> : words) {
            <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #008800; font-weight: bold">const</span> <span style="color: #008800; font-weight: bold">auto</span><span style="color: #333333">&amp;</span> <span style="color: #997700; font-weight: bold">c</span> : word) {
                nodes.emplace(c);
            }
        }
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">1</span>; i <span style="color: #333333">&lt;</span> words.size(); <span style="color: #333333">++</span>i) {
            findEdges(words[i <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>], words[i], <span style="color: #333333">&amp;</span>in_degree, <span style="color: #333333">&amp;</span>out_degree);
        }
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #008800; font-weight: bold">const</span> <span style="color: #008800; font-weight: bold">auto</span><span style="color: #333333">&amp;</span> <span style="color: #997700; font-weight: bold">node</span> : nodes) {
            <span style="color: #008800; font-weight: bold">if</span> (in_degree.find(node) <span style="color: #333333">==</span> in_degree.end()) {
                zero_in_degree_queue.emplace(node);
            }
        }

        <span style="color: #888888">// BFS</span>
        string result;
        <span style="color: #008800; font-weight: bold">while</span> (<span style="color: #333333">!</span>zero_in_degree_queue.empty()) {
            <span style="color: #008800; font-weight: bold">const</span> <span style="color: #008800; font-weight: bold">auto</span><span style="color: #333333">&amp;</span> precedence <span style="color: #333333">=</span> zero_in_degree_queue.front();
            zero_in_degree_queue.pop();
            result.push_back(precedence);
            
            <span style="color: #008800; font-weight: bold">if</span> (out_degree.find(precedence) <span style="color: #333333">!=</span> out_degree.end()) {
                <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #008800; font-weight: bold">const</span> <span style="color: #008800; font-weight: bold">auto</span><span style="color: #333333">&amp;</span> <span style="color: #997700; font-weight: bold">c</span> : out_degree[precedence]) {
                    in_degree[c].erase(precedence);
                    <span style="color: #008800; font-weight: bold">if</span> (in_degree[c].empty()) {
                        zero_in_degree_queue.emplace(c);
                    }
                }
                out_degree.erase(precedence);
            }
        }
        
        <span style="color: #008800; font-weight: bold">if</span> (<span style="color: #333333">!</span>out_degree.empty()) {
            <span style="color: #008800; font-weight: bold">return</span> <span style="background-color: #fff0f0">&quot;&quot;</span>;
        }
        
        <span style="color: #008800; font-weight: bold">return</span> result;
    }

<span style="color: #008800; font-weight: bold">private</span><span style="color: #333333">:</span>
    <span style="color: #888888">// Construct the graph.</span>
    <span style="color: #333399; font-weight: bold">void</span> findEdges(<span style="color: #008800; font-weight: bold">const</span> string <span style="color: #333333">&amp;</span>word1, <span style="color: #008800; font-weight: bold">const</span> string <span style="color: #333333">&amp;</span>word2,
                   unordered_map<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">char</span>, unordered_set<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">char</span><span style="color: #333333">&gt;&gt;</span> <span style="color: #333333">*</span>in_degree,
                   unordered_map<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">char</span>, unordered_set<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">char</span><span style="color: #333333">&gt;&gt;</span> <span style="color: #333333">*</span>out_degree) {
        <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">int</span> len <span style="color: #333333">=</span> min(word1.length(), word2.length());
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> len; <span style="color: #333333">++</span>i) {
            <span style="color: #008800; font-weight: bold">if</span> (word1[i] <span style="color: #333333">!=</span> word2[i]) {
                (<span style="color: #333333">*</span>in_degree)[word2[i]].emplace(word1[i]);
                (<span style="color: #333333">*</span>out_degree)[word1[i]].emplace(word2[i]);
                <span style="color: #008800; font-weight: bold">break</span>;
            }
        }
    }
};

<span style="color: #888888">// DFS solution.</span>
<span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">Solution2</span> {
<span style="color: #008800; font-weight: bold">public</span><span style="color: #333333">:</span>
    string alienOrder(vector<span style="color: #333333">&lt;</span>string<span style="color: #333333">&gt;&amp;</span> words) {
        <span style="color: #888888">// Find ancestors of each node by DFS.</span>
        unordered_set<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">char</span><span style="color: #333333">&gt;</span> nodes;
        unordered_map<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">char</span>, vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">char</span><span style="color: #333333">&gt;&gt;</span> ancestors;
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> words.size(); <span style="color: #333333">++</span>i) {
            <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #008800; font-weight: bold">const</span> <span style="color: #008800; font-weight: bold">auto</span><span style="color: #333333">&amp;</span> <span style="color: #997700; font-weight: bold">c</span> : words[i]) {
                nodes.emplace(c);
            }
            <span style="color: #008800; font-weight: bold">if</span> (i <span style="color: #333333">&gt;</span> <span style="color: #0000DD; font-weight: bold">0</span>) {
                findEdges(words[i <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>], words[i], <span style="color: #333333">&amp;</span>ancestors);
            }
        }

        <span style="color: #888888">// Output topological order by DFS.</span>
        string result;
        unordered_map<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">char</span>, <span style="color: #333399; font-weight: bold">char</span><span style="color: #333333">&gt;</span> visited;
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #008800; font-weight: bold">const</span> <span style="color: #008800; font-weight: bold">auto</span><span style="color: #333333">&amp;</span> <span style="color: #997700; font-weight: bold">node</span> : nodes) {
            <span style="color: #008800; font-weight: bold">if</span> (topSortDFS(node, node, <span style="color: #333333">&amp;</span>ancestors, <span style="color: #333333">&amp;</span>visited, <span style="color: #333333">&amp;</span>result)) {
                <span style="color: #008800; font-weight: bold">return</span> <span style="background-color: #fff0f0">&quot;&quot;</span>;
            }
        }
        
        <span style="color: #008800; font-weight: bold">return</span> result;
    }

<span style="color: #008800; font-weight: bold">private</span><span style="color: #333333">:</span>
    <span style="color: #888888">// Construct the graph.</span>
    <span style="color: #333399; font-weight: bold">void</span> findEdges(<span style="color: #008800; font-weight: bold">const</span> string <span style="color: #333333">&amp;</span>word1, <span style="color: #008800; font-weight: bold">const</span> string <span style="color: #333333">&amp;</span>word2,
                   unordered_map<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">char</span>, vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">char</span><span style="color: #333333">&gt;&gt;</span> <span style="color: #333333">*</span>ancestors) {
        <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">int</span> len <span style="color: #333333">=</span> min(word1.length(), word2.length());
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> len; <span style="color: #333333">++</span>i) {
            <span style="color: #008800; font-weight: bold">if</span> (word1[i] <span style="color: #333333">!=</span> word2[i]) {
                (<span style="color: #333333">*</span>ancestors)[word2[i]].emplace_back(word1[i]);
                <span style="color: #008800; font-weight: bold">break</span>;
            }
        }
    }

    <span style="color: #888888">// Topological sort, return whether there is a cycle.</span>
    <span style="color: #333399; font-weight: bold">bool</span> topSortDFS(<span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">char</span><span style="color: #333333">&amp;</span> root,
                    <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">char</span><span style="color: #333333">&amp;</span> node,
                    unordered_map<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">char</span>, vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">char</span><span style="color: #333333">&gt;&gt;</span> <span style="color: #333333">*</span>ancestors,
                    unordered_map<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">char</span>, <span style="color: #333399; font-weight: bold">char</span><span style="color: #333333">&gt;</span> <span style="color: #333333">*</span>visited,
                    string <span style="color: #333333">*</span>result) {
        <span style="color: #008800; font-weight: bold">if</span> (visited<span style="color: #333333">-&gt;</span>emplace(make_pair(node, root)).second) {
            <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #008800; font-weight: bold">auto</span><span style="color: #333333">&amp;</span> <span style="color: #997700; font-weight: bold">ancestor</span>: (<span style="color: #333333">*</span>ancestors)[node]) {
                <span style="color: #008800; font-weight: bold">if</span> (topSortDFS(root, ancestor, ancestors, visited, result)) {
                    <span style="color: #008800; font-weight: bold">return</span> <span style="color: #007020">true</span>;
                }
            }
            result<span style="color: #333333">-&gt;</span>push_back(node);
        } <span style="color: #008800; font-weight: bold">else</span> <span style="color: #008800; font-weight: bold">if</span> ((<span style="color: #333333">*</span>visited)[node] <span style="color: #333333">==</span> root) {
            <span style="color: #888888">// Visited from the same root in the DFS path.</span>
            <span style="color: #888888">// So it is cyclic.</span>
            <span style="color: #008800; font-weight: bold">return</span> <span style="color: #007020">true</span>;
        }
        <span style="color: #008800; font-weight: bold">return</span> <span style="color: #007020">false</span>;
    } 
};

<span style="color: #888888">// DFS with adjacency matrix solution.</span>
<span style="color: #008800; font-weight: bold">class</span> <span style="color: #BB0066; font-weight: bold">Solution3</span> {
<span style="color: #008800; font-weight: bold">public</span><span style="color: #333333">:</span>
    string alienOrder(vector<span style="color: #333333">&lt;</span>string<span style="color: #333333">&gt;&amp;</span> words) {
        string result;
        vector<span style="color: #333333">&lt;</span>vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">bool</span><span style="color: #333333">&gt;&gt;</span> graph(<span style="color: #0000DD; font-weight: bold">26</span>, vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">bool</span><span style="color: #333333">&gt;</span>(<span style="color: #0000DD; font-weight: bold">26</span>));
        findDependency(words, <span style="color: #333333">&amp;</span>graph);
        findOrder(<span style="color: #333333">&amp;</span>graph, <span style="color: #333333">&amp;</span>result);
        <span style="color: #008800; font-weight: bold">return</span> result;
    }

<span style="color: #008800; font-weight: bold">private</span><span style="color: #333333">:</span>
    <span style="color: #333399; font-weight: bold">void</span> findEdges(<span style="color: #008800; font-weight: bold">const</span> string <span style="color: #333333">&amp;</span>word1, <span style="color: #008800; font-weight: bold">const</span> string <span style="color: #333333">&amp;</span>word2, vector<span style="color: #333333">&lt;</span>vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">bool</span><span style="color: #333333">&gt;&gt;</span> <span style="color: #333333">*</span>graph) {
        <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">int</span> len <span style="color: #333333">=</span> min(word1.length(), word2.length());
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> len; <span style="color: #333333">++</span>i) {
            <span style="color: #008800; font-weight: bold">if</span> (word1[i] <span style="color: #333333">!=</span> word2[i]) {
                (<span style="color: #333333">*</span>graph)[word1[i] <span style="color: #333333">-</span> <span style="color: #0044DD">&#39;a&#39;</span>][word2[i] <span style="color: #333333">-</span> <span style="color: #0044DD">&#39;a&#39;</span>] <span style="color: #333333">=</span> <span style="color: #007020">true</span>;
                <span style="color: #008800; font-weight: bold">break</span>;
            }
        }
    }

    <span style="color: #888888">// Construct the graph.</span>
    <span style="color: #333399; font-weight: bold">void</span> findDependency(<span style="color: #008800; font-weight: bold">const</span> vector<span style="color: #333333">&lt;</span>string<span style="color: #333333">&gt;&amp;</span> words, vector<span style="color: #333333">&lt;</span>vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">bool</span><span style="color: #333333">&gt;&gt;</span> <span style="color: #333333">*</span>graph) {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #008800; font-weight: bold">const</span> <span style="color: #008800; font-weight: bold">auto</span><span style="color: #333333">&amp;</span> <span style="color: #997700; font-weight: bold">c</span> : words[<span style="color: #0000DD; font-weight: bold">0</span>]) {
            (<span style="color: #333333">*</span>graph)[c <span style="color: #333333">-</span> <span style="color: #0044DD">&#39;a&#39;</span>][c <span style="color: #333333">-</span> <span style="color: #0044DD">&#39;a&#39;</span>] <span style="color: #333333">=</span> <span style="color: #007020">true</span>;
        }
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">1</span>; i <span style="color: #333333">&lt;</span> words.size(); <span style="color: #333333">++</span>i) {
            <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #008800; font-weight: bold">const</span> <span style="color: #008800; font-weight: bold">auto</span><span style="color: #333333">&amp;</span> <span style="color: #997700; font-weight: bold">c</span> : words[i]) {
                (<span style="color: #333333">*</span>graph)[c <span style="color: #333333">-</span> <span style="color: #0044DD">&#39;a&#39;</span>] [c <span style="color: #333333">-</span> <span style="color: #0044DD">&#39;a&#39;</span>] <span style="color: #333333">=</span> <span style="color: #007020">true</span>;
            }
            findEdges(words[i <span style="color: #333333">-</span> <span style="color: #0000DD; font-weight: bold">1</span>], words[i], graph);
        }
    }

    <span style="color: #888888">// Topological sort, return whether there is a cycle.</span>
    <span style="color: #333399; font-weight: bold">bool</span> topSortDFS(string <span style="color: #333333">*</span>result, vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">bool</span><span style="color: #333333">&gt;</span> <span style="color: #333333">*</span>visited,
                    vector<span style="color: #333333">&lt;</span>vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">bool</span><span style="color: #333333">&gt;&gt;</span> <span style="color: #333333">*</span>graph, <span style="color: #008800; font-weight: bold">const</span> <span style="color: #333399; font-weight: bold">int</span> root) {
        <span style="color: #008800; font-weight: bold">if</span> ((<span style="color: #333333">*</span>visited)[root]) {
            result<span style="color: #333333">-&gt;</span>clear();
            <span style="color: #008800; font-weight: bold">return</span> <span style="color: #007020">true</span>;
        }
        (<span style="color: #333333">*</span>visited)[root] <span style="color: #333333">=</span> <span style="color: #007020">true</span>;
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> <span style="color: #0000DD; font-weight: bold">26</span>; <span style="color: #333333">++</span>i) {
            <span style="color: #008800; font-weight: bold">if</span> (i <span style="color: #333333">!=</span> root <span style="color: #333333">&amp;&amp;</span> (<span style="color: #333333">*</span>graph)[root][i]) {
                <span style="color: #008800; font-weight: bold">if</span> (topSortDFS(result, visited, graph, i)) {
                    <span style="color: #008800; font-weight: bold">return</span> <span style="color: #007020">true</span>;
                }
            }
        }
        (<span style="color: #333333">*</span>graph)[root][root] <span style="color: #333333">=</span> <span style="color: #007020">false</span>;
        result<span style="color: #333333">-&gt;</span>push_back(root <span style="color: #333333">+</span> <span style="color: #0044DD">&#39;a&#39;</span>);
        <span style="color: #008800; font-weight: bold">return</span> <span style="color: #007020">false</span>;
    }  

    <span style="color: #333399; font-weight: bold">void</span> findOrder(vector<span style="color: #333333">&lt;</span>vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">bool</span><span style="color: #333333">&gt;&gt;</span> <span style="color: #333333">*</span>graph, string <span style="color: #333333">*</span>result) {
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> <span style="color: #0000DD; font-weight: bold">26</span>; <span style="color: #333333">++</span>i) {
            <span style="color: #888888">// Find a root node.</span>
            <span style="color: #333399; font-weight: bold">bool</span> root_node <span style="color: #333333">=</span> (<span style="color: #333333">*</span>graph)[i][i];
            <span style="color: #008800; font-weight: bold">if</span> ((<span style="color: #333333">*</span>graph)[i][i]) {
                <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> j <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; j <span style="color: #333333">&lt;</span> <span style="color: #0000DD; font-weight: bold">26</span>; <span style="color: #333333">++</span>j) {
                    <span style="color: #008800; font-weight: bold">if</span> (j <span style="color: #333333">!=</span> i <span style="color: #333333">&amp;&amp;</span> (<span style="color: #333333">*</span>graph)[j][i]) {
                        root_node <span style="color: #333333">=</span> <span style="color: #007020">false</span>;
                        <span style="color: #008800; font-weight: bold">break</span>;
                    }
                }
            }
            <span style="color: #008800; font-weight: bold">if</span> (root_node) {
                string reversed_order <span style="color: #333333">=</span> <span style="background-color: #fff0f0">&quot;&quot;</span>;
                vector<span style="color: #333333">&lt;</span><span style="color: #333399; font-weight: bold">bool</span><span style="color: #333333">&gt;</span> visited(<span style="color: #0000DD; font-weight: bold">26</span>, <span style="color: #007020">false</span>);
                <span style="color: #008800; font-weight: bold">if</span> (topSortDFS(<span style="color: #333333">&amp;</span>reversed_order, <span style="color: #333333">&amp;</span>visited, graph, i)) {
                    result<span style="color: #333333">-&gt;</span>clear();
                    <span style="color: #008800; font-weight: bold">return</span>;
                } <span style="color: #008800; font-weight: bold">else</span> {
                    result<span style="color: #333333">-&gt;</span>append(reversed_order);
                }
            }
        }

        <span style="color: #888888">// If there is any unvisited node, return &quot;&quot;.</span>
        <span style="color: #008800; font-weight: bold">for</span> (<span style="color: #333399; font-weight: bold">int</span> i <span style="color: #333333">=</span> <span style="color: #0000DD; font-weight: bold">0</span>; i <span style="color: #333333">&lt;</span> <span style="color: #0000DD; font-weight: bold">26</span>; <span style="color: #333333">++</span>i) {
            <span style="color: #008800; font-weight: bold">if</span> ((<span style="color: #333333">*</span>graph)[i][i]) {
                result<span style="color: #333333">-&gt;</span>clear();
                <span style="color: #008800; font-weight: bold">return</span>;
            }
        }
        <span style="color: #888888">// The order should be reversed.</span>
        reverse(result<span style="color: #333333">-&gt;</span>begin(), result<span style="color: #333333">-&gt;</span>end());
    }
};
</pre></div>
